/**
 * Senzing REST API
 * This is the Senzing REST API.  It describes the REST interface to Senzing API functions available via REST.  It leverages the Senzing native API which is documented at [https://docs.senzing.com](https://docs.senzing.com)
 *
 * OpenAPI spec version: 1.8.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';
import { tap, catchError }                                               from 'rxjs/operators';

import { SzBulkDataAnalysisResponse } from '../model/szBulkDataAnalysisResponse';
import { SzBulkDataLoadResponse } from '../model/szBulkDataLoadResponse';
import { SzErrorResponse } from '../model/szErrorResponse';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class BulkDataService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Analyze a bulk data set of records
     * 
     * @param data 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public analyzeBulkRecords(body: string | Blob | File | Array<{ [key: string]: any; }>, observe?: 'body', reportProgress?: boolean): Observable<SzBulkDataAnalysisResponse>;
    public analyzeBulkRecords(body: string | Blob | File | Array<{ [key: string]: any; }>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzBulkDataAnalysisResponse>>;
    public analyzeBulkRecords(body: string | Blob | File | Array<{ [key: string]: any; }>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzBulkDataAnalysisResponse>>;
    public analyzeBulkRecords(body: string | Blob | File | Array<{ [key: string]: any; }>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter data was null or undefined when calling analyzeBulkRecords.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/x-jsonlines; charset=UTF-8',
            'application/x-jsonlines',
            'application/vnd.ms-excel',
            'application/json; charset=UTF-8',
            'application/json',
            'text/csv; charset=UTF-8',
            'text/csv',
            'text/plain; charset=UTF-8',
            'text/plain',
            'multipart/form-data'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if ((body as File).type) {
            // is file upload? probably? 
            console.log('BulkDataService.analyzeBulkRecords set content type to ', httpContentTypeSelected);
            headers = headers.set('Content-Type', "text/plain");
        } else if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (body !== undefined) {
            formParams = formParams.append('data', <any>body) as any || formParams;
        }

        return this.httpClient.post<SzBulkDataAnalysisResponse>(`${this.basePath}/bulk-data/analyze`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Load the records in the provided bulk data set.
     * 
     * @param body The bulk record data as a single JSON record per line, a JSON array, or a CSV.  Further, multipart/form-data can be provided with the &quot;data&quot; property representing the record data as described above.  Set your content type accordingly.  The data should be in pre-mapped format using JSON property names or CSV column names as described by the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification).
     * @param dataSource Used to set the overriding data source for the records.  This data source will be assigned to every record unless the record has a data source already and that data source has a specific override specified by a &#x60;dataSource_xxxx&#x60; parameter.  For example &#x60;dataSource_EMPL&#x60; will map the &#x60;EMPL&#x60; data source to the specified value.
     * @param entityType Used to set the overriding entity type for the records.  This entity type will be assigned to every record unless the record already has an entity type and that data source has a specific override specified by a &#x60;entityType_xxxx&#x60; parameter.  For example &#x60;entityType_PERSON&#x60; will map the &#x60;PERSON&#x60; entity type to the specified value.  If no override is provided then the entity type specified for the record is used directly, unless the record has no entity type in which case an entity type by the same name as the data source is used.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loadBulkRecords(body: string | Blob | File, dataSource?: string | { [key: string]: string }, entityType?: string | { [key: string]: string }, observe?: 'body', reportProgress?: boolean): Observable<SzBulkDataLoadResponse>;
    public loadBulkRecords(body: string | Blob | File, dataSource?: string | { [key: string]: string }, entityType?: string | { [key: string]: string }, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzBulkDataLoadResponse>>;
    public loadBulkRecords(body: string | Blob | File, dataSource?: string | { [key: string]: string }, entityType?: string | { [key: string]: string }, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzBulkDataLoadResponse>>;
    public loadBulkRecords(body: string | Blob | File, dataSource?: string | { [key: string]: string }, entityType?: string | { [key: string]: string }, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        let prefix = '';
        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling loadBulkRecords.');
        }

        if (dataSource !== undefined && dataSource !== null) {
            if((dataSource as { [key: string]: string }) && typeof (dataSource as { [key: string]: string }) !== 'string') {
              for (const key in (dataSource as { [key: string]: string })) {
                  if(key === null || key === 'null' || key === 'NULL') {
                    queryParameters = queryParameters.append('dataSource', dataSource[key]);
                    console.log('BulkDataService.loadBulkRecords append "dataSource" to: '+ dataSource[key], queryParameters);
                  } else {
                    queryParameters = queryParameters.append('dataSource_'+key, dataSource[key]);
                    console.log('BulkDataService.loadBulkRecords append "'+ 'dataSource_'+key +'" to: '+ dataSource[key], queryParameters);
                  }
                  //console.log('BulkDataService.loadBulkRecords entity types set to: ', queryParameters);
              }
            } else {
              // is single ds
              queryParameters = queryParameters.set('dataSource', <any>dataSource);
            }
        }

        if (entityType !== undefined && entityType !== null) {
          if((entityType as { [key: string]: string }) && typeof (entityType as { [key: string]: string }) !== 'string') {
            //const _etArr = [];
            for (const key in (entityType as { [key: string]: string })) {
                //_etArr.push( entityType[key] );
                if(key === null || key === 'null' || key === 'NULL') {
                  queryParameters = queryParameters.append('entityType', entityType[key]);
                } else {
                  queryParameters = queryParameters.append('entityType_'+key, entityType[key]);
                }
                //console.log('BulkDataService.loadBulkRecords entity types set to: ', queryParameters);
            }
          } else {
            // is single et
            queryParameters = queryParameters.set('entityType', <any>entityType);
          }
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/x-jsonlines; charset=UTF-8',
            'application/x-jsonlines',
            'application/json; charset=UTF-8',
            'application/json',
            'application/vnd.ms-excel',
            'text/csv; charset=UTF-8',
            'text/csv',
            'text/plain; charset=UTF-8',
            'text/plain',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/x-jsonlines; charset=UTF-8',
            'application/x-jsonlines',
            'application/json; charset=UTF-8',
            'application/json',
            'application/vnd.ms-excel',
            'text/csv; charset=UTF-8',
            'text/csv',
            'text/plain; charset=UTF-8',
            'text/plain',
            'multipart/form-data'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if ((body as File).type) {
            // is file upload? probably? 
            console.log('BulkDataService.loadBulkRecords set content type to ', httpContentTypeSelected, (body as File).type);
            headers = headers.set('Content-Type', "text/plain");
            /*
            if(consumes.indexOf((body as File).type) >= 0) {
              // try the type specified by the file
              headers = headers.set('Content-Type', ((body as File).type));
            } else {
              headers = headers.set('Content-Type', httpContentTypeSelected);
            }*/
        } else if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (body !== undefined) {
            formParams = formParams.append('data', <any>body) as any || formParams;
        }

        return this.httpClient.post<SzBulkDataLoadResponse>(`${this.basePath}/bulk-data/load`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        ).pipe(
            tap( (resp) => {
                console.log('BulkDataService.loadBulkRecords: ', resp);
            })
        );
    }
}
