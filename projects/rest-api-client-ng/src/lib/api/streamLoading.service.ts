/**
 * Senzing POC REST API
 * This is the Senzing POC REST API.  This API is <b>NOT</b> maintained for backwards compatibility.  This API extends the [Senzing REST API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/Senzing/senzing-rest-api-specification/master/senzing-rest-api.yaml) which is maintained for backwards compatibility.  However, the Senzing POC API is specifically targeted at the Senzing One-Day POC application and no guarantees are made for support.  It can be used as example for creating your own extended API. <br><br> <b>SSE NOTE:</b> Some end-points described here will indicate \"(Supports SSE)\" to indicate that they support \"Server-sent Events\" via the `text/event-stream` media type.  This support is activated by adding the `Accept: text/event-stream` header to a request to override the default `application/json` media type.  Further, the end-point will behave similarly to its standard operation but will produce `progress` events at regular intervals that are equivalent to its `200` response schema. Upon success, the final event will be `completed` with the same response schema as a `200` response.  Upon failure, the final event will be `failed` with same schema as the `4xx` or `5xx` response (typically the `SzErrorResponse`) <br><br> <b>WEB SOCKETS NOTE:</b> Some end-points described here will indicate \"(Supports WebSockets)\" to indicate that they can invoked via the Web Sockets protocol. This support is activated by invoking the end-point using the `ws://` protocol in the URL.  Any request query parameters can still be sent on the URL and the request body can be sent as one or more message from the client (as documented).  The end-point response will be sent as one or more response messages as documented (sometimes describing progress as with SSE end-points).  Upon failure responses will follow the same schema as the `4xx` or `5xx` response (typically the `SzErrorResponse`)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';
import { webSocket, WebSocketSubject }                       from 'rxjs/webSocket';


//import { ModelObject } from '../model/modelObject';
import { SzBaseResponse } from '../model/szBaseResponse';
import { SzBulkLoadResponse } from '../model/szBulkLoadResponse';
import { SzErrorResponse } from '../model/szErrorResponse';
import { SzQueueInfoResponse } from '../model/szQueueInfoResponse';

import { BASE_PATH, WEBSOCKET_BASE_PATH, COLLECTION_FORMATS }   from '../variables';
import { Configuration, WebSocketConnectionConfiguration, WebSocketConnectionParameters }      from '../configuration';
import { SzPocWebSocketService }                                   from './websocket.service';

@Injectable()
export class StreamLoadingService {

    protected basePath  = 'http://localhost:8250';
    protected wsPath;

    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public webSocketConfiguration = new WebSocketConnectionConfiguration();

    constructor(protected httpClient: HttpClient, private webSocketService: SzPocWebSocketService, @Optional()@Inject(BASE_PATH) basePath: string, @Optional()@Inject(WEBSOCKET_BASE_PATH) wsPath: string, @Optional() configuration: Configuration, @Optional() webSocketConfiguration: WebSocketConnectionConfiguration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (wsPath) {
            this.wsPath = wsPath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath   = basePath || configuration.basePath || this.basePath;
            //this.wsPath     = wsPath || configuration.webSocketBasePath || this.wsPath; 
        }
        if(webSocketConfiguration) {
            this.webSocketConfiguration = webSocketConfiguration;
            this.wsPath     = wsPath || WebSocketConnectionConfiguration.getSocketUriFromConnectionObject(webSocketConfiguration) || this.wsPath; 
        }
    }

    set webSocketConnectionProperties(webSocketConnectionParameters: WebSocketConnectionParameters) {
        this.webSocketConfiguration.connectionParameters = webSocketConnectionParameters;
    }
    get webSocketConnectionProperties(): WebSocketConnectionParameters {
        return this.webSocketConfiguration.connectionParameters;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Gets the properties of the configured load queue.
     * Obtains the properties of the configured load queue
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLoadQueueInfo(observe?: 'body', reportProgress?: boolean): Observable<SzQueueInfoResponse>;
    public getLoadQueueInfo(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzQueueInfoResponse>>;
    public getLoadQueueInfo(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzQueueInfoResponse>>;
    public getLoadQueueInfo(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<SzQueueInfoResponse>('get',`${this.basePath}/load-queue`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Adds a record to the configured asynchronous load queue in order to koad a new record specified in a data source with either an auto-generated record ID or a &#x60;RECORD_ID&#x60; specified in the payload.
     * This operation appends a single record to the configured load queue using the data source identified by the data source code in the request path.  The provided record in the request body is described in JSON using the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). The provided record may contain a &#x60;RECORD_ID&#x60; to identify it uniquely among other records in the same data source, but if it does not then a record ID will be automatically generated.  **NOTE:** The actual loading of the record must be handled externally by a consumer of the messages on the configured load queue. 
     * @param body The record data as JSON.  The format of the JSON is described by the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). The specified JSON may include or exclude the DATA_SOURCE field. It will be added if excluded.  If included, it must match the data source code in the path parameters.
     * @param dataSourceCode The data source code identifying the data source.
     * @param loadId The optional load ID to associate with the loaded record.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRecordToLoadQueue(body: { [key: string]: any; }, dataSourceCode: string, loadId?: string, observe?: 'body', reportProgress?: boolean): Observable<SzBaseResponse>;
    public postRecordToLoadQueue(body: { [key: string]: any; }, dataSourceCode: string, loadId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzBaseResponse>>;
    public postRecordToLoadQueue(body: { [key: string]: any; }, dataSourceCode: string, loadId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzBaseResponse>>;
    public postRecordToLoadQueue(body: { [key: string]: any; }, dataSourceCode: string, loadId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if(!this.wsPath) {
            throw new Error('WebsocketBasePath is not defined. postRecordToLoadQueue is a WebSocket interface.');
        }

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postRecordToLoadQueue.');
        }

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling postRecordToLoadQueue.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (loadId !== undefined && loadId !== null) {
            queryParameters = queryParameters.set('loadId', <any>loadId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json; charset=UTF-8',
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        
        return this.webSocketService.sendMessage( JSON.stringify(body) );
        /*
        return this.httpClient.request<SzBaseResponse>('post',`${this.basePath}/load-queue/data-sources/${encodeURIComponent(String(dataSourceCode))}/records`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );*/
    }

        /**
     * Adds a record to the configured asynchronous load queue in order to koad a new record specified in a data source with either an auto-generated record ID or a &#x60;RECORD_ID&#x60; specified in the payload.
     * This operation appends a single record to the configured load queue using the data source identified by the data source code in the request path.  The provided record in the request body is described in JSON using the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). The provided record may contain a &#x60;RECORD_ID&#x60; to identify it uniquely among other records in the same data source, but if it does not then a record ID will be automatically generated.  **NOTE:** The actual loading of the record must be handled externally by a consumer of the messages on the configured load queue. 
     * @param body The record data as JSON.  The format of the JSON is described by the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). The specified JSON may include or exclude the DATA_SOURCE field. It will be added if excluded.  If included, it must match the data source code in the path parameters.
     * @param dataSourceCode The data source code identifying the data source.
     * @param loadId The optional load ID to associate with the loaded record.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postRecordsToLoadQueue(body: { [key: string]: any; }[], dataSource?: string, mapDataSources?: string, mapDataSource?: Array<string>, entityType?: string, mapEntityTypes?: string, mapEntityType?: Array<string>, loadId?: string, observe?: 'body', reportProgress?: boolean): Observable<SzBaseResponse>;
    public postRecordsToLoadQueue(body: { [key: string]: any; }[], dataSource?: string, mapDataSources?: string, mapDataSource?: Array<string>, entityType?: string, mapEntityTypes?: string, mapEntityType?: Array<string>, loadId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzBaseResponse>>;
    public postRecordsToLoadQueue(body: { [key: string]: any; }[], dataSource?: string, mapDataSources?: string, mapDataSource?: Array<string>, entityType?: string, mapEntityTypes?: string, mapEntityType?: Array<string>, loadId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzBaseResponse>>;
    public postRecordsToLoadQueue(body: { [key: string]: any; }[], dataSource?: string, mapDataSources?: string, mapDataSource?: Array<string>, entityType?: string, mapEntityTypes?: string, mapEntityType?: Array<string>, loadId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        /*if(!this.wsPath) {
            throw new Error('WebsocketBasePath is not defined. postRecordToLoadQueue is a WebSocket interface.');
        }*/

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postRecordToLoadQueue.');
        }
        /*
        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling postRecordToLoadQueue.');
        }*/


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (loadId !== undefined && loadId !== null) {
            queryParameters = queryParameters.set('loadId', <any>loadId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json; charset=UTF-8',
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        // socket related
        let streamSocketEndpoint        = "/load-queue/bulk-data/records";
        let qsChar                      = '?';
        if(mapDataSources) {
            streamSocketEndpoint        += `${qsChar}mapDataSources=${encodeURIComponent(mapDataSources)}`;
            qsChar = '&';
        }
        if(mapEntityTypes) {
            streamSocketEndpoint        += `${qsChar}mapEntityTypes=${encodeURIComponent(mapEntityTypes)}`;
            qsChar = '&';
        }
        streamSocketEndpoint            += `${qsChar}eofSendTimeout=40&progressPeriod=60`;
        this.webSocketService.reconnect(streamSocketEndpoint)
        return this.webSocketService.sendMessages( body );
        /*
        return this.httpClient.request<SzBaseResponse>('post',`${this.basePath}/load-queue/data-sources/${encodeURIComponent(String(dataSourceCode))}/records`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );*/
    }

    /**
     * Adds a record to the configured asynchronous load queue in order to load a new record or replace a record in a data source with a specific record ID.
     * This operation appends a single record to the configured load queue using the data source identified by the data source code in the request path.  The record will be identified uniquely within the data source by the record ID provided in the request path.  The provided record in the request body is described in JSON using the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). The provided JSON record may omit the &#x60;RECORD_ID&#x60;, but if it contains a &#x60;RECORD_ID&#x60; then it **must** match the record ID provided on the request path.  The record ID is returned as part of the response.  **NOTE:** The actual loading of the record must be handled externally by a consumer of the messages on the configured load queue. 
     * @param body The record data as JSON.  The format of the JSON is described by the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification). The specified JSON may include or exclude the DATA_SOURCE and RECORD_ID fields.  Any excluded field will be added to the JSON accordingly.  Any included field in the JSON, must match the respective path parameter for data source code or record ID.
     * @param dataSourceCode The data source code identifying the data source.
     * @param recordId The identifier that uniquely identifies the requested record within a given data source.  This may have been specified when the record was loaded or generated automatically.
     * @param loadId The optional load ID to associate with the loaded record.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public putRecordOnLoadQueue(body: { [key: string]: any; }, dataSourceCode: string, recordId: string, loadId?: string, observe?: 'body', reportProgress?: boolean): Observable<SzBaseResponse>;
    public putRecordOnLoadQueue(body: { [key: string]: any; }, dataSourceCode: string, recordId: string, loadId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzBaseResponse>>;
    public putRecordOnLoadQueue(body: { [key: string]: any; }, dataSourceCode: string, recordId: string, loadId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzBaseResponse>>;
    public putRecordOnLoadQueue(body: { [key: string]: any; }, dataSourceCode: string, recordId: string, loadId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if(!this.wsPath) {
            throw new Error('WebsocketBasePath is not defined. postRecordToLoadQueue is a WebSocket interface.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putRecordOnLoadQueue.');
        }

        if (dataSourceCode === null || dataSourceCode === undefined) {
            throw new Error('Required parameter dataSourceCode was null or undefined when calling putRecordOnLoadQueue.');
        }

        if (recordId === null || recordId === undefined) {
            throw new Error('Required parameter recordId was null or undefined when calling putRecordOnLoadQueue.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (loadId !== undefined && loadId !== null) {
            queryParameters = queryParameters.set('loadId', <any>loadId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json; charset=UTF-8',
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<SzBaseResponse>('put',`${this.basePath}/load-queue/data-sources/${encodeURIComponent(String(dataSourceCode))}/records/${encodeURIComponent(String(recordId))}`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Load the records in the provided bulk data set. (Supports SSE / Supports Web Sockets)
     * Provides a means to load a bulk data file of records via an asynchronous load queue.  The records are encoded as a JSON array of JSON objects, a single JSON object per line in JSON-lines file format, or as a CSV with one record per row.  The data should be in pre-mapped format using JSON property names or CSV column names as described by the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification).  **SCALABILITY NOTE:** This operation can be invoked in three ways.  In order of increasingly better scalability these are listed below:   1. Standard HTTP Request/Response   2. HTTP Request with SSE Response (see below)   3. HTTP Upgrade Request for Web Sockets (see below)  Standard HTTP Request/Response (method 1) has the worst scalability because a long-running operation will tie up a Web Server thread **and** continue until complete even if the client aborts the operation since no data is written back to the client until complete and therefore the terminated connection will not be detected.  SSE (method 2) mitigates the problem of detecting when a client has aborted the operation because periodic progress responses are written to the client and therefore a terminated connection will be detected.  However, the best way to invoke this operation is via Web Sockets (method 3) which not only can detect disconnection of the client, but it also upgrades the request to use its own thread outside the Web Server thread pool.  **SSE NOTE:** This end-point supports \&quot;Server-sent Events\&quot; (SSE) via the &#x60;text/event-stream&#x60; media type.  This support is activated by adding the &#x60;Accept: text/event-stream&#x60; header to a request to override the default &#x60;application/json&#x60; media type.  Further, the end-point will behave similarly to its standard operation but will produce &#x60;progress&#x60; events at regular intervals that are equivalent to its &#x60;200&#x60; response schema. Upon success, the final event will be &#x60;completed&#x60; with the same response schema as a &#x60;200&#x60; response.  Upon failure, the final event will be &#x60;failed&#x60; with same &#x60;SzErrorResponse&#x60; schema as the &#x60;4xx&#x60; or &#x60;5xx&#x60;.  **WEB SOCKETS NOTE**: If invoking via Web Sockets then the client may send text or binary chunks of the JSON, JSON-Lines or CSV bulk data file as messages.  In Web Sockets, text messages are *always* sent as UTF-8. If the file&#x27;s character encoding is unknown then the client should send binary messages and the server will attempt to auto-detect the character encoding.  Each message should adhere to the maximum message size specified by the &#x60;webSocketsMessageMaxSize&#x60; property returned by the &#x60;GET /server-info&#x60; end-point.  The end of file is detected when the number of seconds specified by the &#x60;eofSendTimeout&#x60; query parameter have elapsed without a new message being received. 
     * @param body The bulk record data as a single JSON record per line, a JSON array,
        or a CSV.  Further, &#x60;multipart/form-data&#x60; can be provided with the
        "data" property representing the record data as described above.  Set
        your content type accordingly.  The data should be in pre-mapped
        format using JSON property names or CSV column names as described by
        the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification).

     * @param dataSource Used to set the overriding data source for the records.  This data source will be assigned to every record **unless** the record&#x27;s data source (including blank data source) has a specific mapping specified by a &#x60;mapDataSources&#x60; or &#x60;mapDataSource&#x60; parameters.  If this parameter is **not** provided and no specific overrides are provided for a record then the data source specified in the inbound record is used directly.  If the record has no data source and no override is provided then it will fail to load. 
     * @param mapDataSources A URL-encoded JSON object whose properties are interpreted as data source codes to map from and whose corresponding values are interpretted as data source codes to map to.  For example, &#x60;{\&quot;EMPL\&quot;: \&quot;EMPLOYEES\&quot;}&#x60; (url-encoded of course) would map all records with inbound data source &#x60;EMPL&#x60; to &#x60;EMPLOYEES&#x60;.  To map only inbound records with no data source to a specific data source you would use an empty JSON property (e.g.: &#x60;{\&quot;\&quot;: \&quot;CUSTOMERS\&quot;}&#x60;). If the &#x60;dataSource&#x60; parameter is **not** provided and no specific overrides are provided for a record with this parameter or via &#x60;mapDataSource&#x60; then the data source specified in the inbound record is used directly.  If the record has no data source and no overriding or mapped data source is provided for an empty data source then the record will fail to load.  **NOTE**: If both this parameter and the &#x60;mapDataSource&#x60; parameter is provided then the mappings are merged with the more ad-hoc &#x60;mapDataSource&#x60; parameter taking precedence since it is likely being used for debugging and diagnostic purposes to avoid the URL encoding.  Here are some examples of encoding this parameter:  - **JavaScript Example**   &#x60;&#x60;&#x60;javascript     var dataSourceMap &#x3D; {       \&quot;\&quot;: \&quot;CUSTOMERS\&quot;,       \&quot;EMPL\&quot;: \&quot;EMPLOYEES\&quot;,       \&quot;VEND\&quot;: \&quot;VENDORS\&quot;     };     var mapDataSources &#x3D; JSON.stringify(dataSourceMap);     var urlPath &#x3D; \&quot;/bulk-data/load?mapDataSources&#x3D;\&quot;                 + encodeURIComponent(mapDataSources);   &#x60;&#x60;&#x60;  - **Java Example**   &#x60;&#x60;&#x60;java     JsonObjectBuilder builder &#x3D; Json.createObjectBuilder();     builder.add(\&quot;\&quot;, \&quot;CUSTOMERS\&quot;);     builder.add(\&quot;EMPL\&quot;, \&quot;EMPLOYEES\&quot;);     builder.add(\&quot;VEND\&quot;, \&quot;VENDORS\&quot;);     JsonObject dataSourceMap &#x3D; builder.build();      String mapDataSources &#x3D; dataSourceMap.toString();     String encodedMap     &#x3D; URLEncoder.encode(mapDataSources, \&quot;UTF-8\&quot;);     String urlPath &#x3D; \&quot;/bulk-data/load?mapDataSources&#x3D;\&quot; + encodedMap;   &#x60;&#x60;&#x60;  In both of the above examples the &#x60;urlPath&#x60; variable is set to: &#x60;&#x60;&#x60;json  /bulk-data/load?mapDataSources&#x3D;%7B%22%22%3A%22CUSTOMERS%22%2C%22EMPL%22%3A%22EMPLOYEES%22%2C%22VEND%22%3A%22VENDORS%22%7D  &#x60;&#x60;&#x60; 
     * @param mapDataSource As an alternative to the &#x60;mapDataSources&#x60; parameter you may specify the &#x60;mapDataSource&#x60; parameter zero or more times to add additional data source mappings or **override** data source mappings from &#x60;mapDataSources&#x60;.  If you are using this API programmatically then you should typically use the &#x60;mapDataSources&#x60; parameter instead of this one.  But when manually constructing a URL in the browser address bar, in a command-line tool like &#x60;curl&#x60; or in a REST client browser extension for debugging or testing purposes, encoding the JSON value for &#x60;mapDataSources&#x60; can be unwieldy.  This parameter (which is multi-valued) lets you specify delimited strings that begin with the delimiter character, followed by the original data source name, then the delimiter character and the new data source name.  You should only have to URL-encode the delimiter you choose and maybe spaces.  For example, &#x60;:EMPL:EMPLOYEES&#x60; or &#x60;|EMPL|EMPLOYEES&#x60; (url-encoded of course) would map all records with inbound data source &#x60;EMPL&#x60; to &#x60;EMPLOYEES&#x60;.  To map only inbound records with no data source to a specific data source you would begin the value with two repeated delimiter characters followed by the new data source value (e.g.: &#x60;||CUSTOMERS&#x60; or &#x60;::CUSTOMERS&#x60;). If the &#x60;dataSource&#x60; parameter is **not** provided and no specific overrides are provided for a record with this parameter or the &#x60;mapDataSources&#x60; parameter then the data source specified in the inbound record is used directly.  If the record has no data source and no overriding or mapped data source is provided for an empty data source then the record will fail to load. 
     * @param entityType Used to set the overriding entity type for the records.  This entity type will be assigned to every record **unless** the record&#x27;s entity type (including blank entity type) has a specific mapping specified by a &#x60;mapEntityTypes&#x60; or &#x60;mapEntityType&#x60; parameters.  If this parameter is **not** provided and no specific overrides are provided for a record then the entity type specified in the inbound record is used directly.  If the record has no entity type and no override is provided then &#x60;GENERIC&#x60; will be used.
     * @param mapEntityTypes A URL-encoded JSON object whose properties are interpreted as entity type codes to map from and whose corresponding values are interpretted as entity type codes to map to.  For example, &#x60;{\&quot;COMPANY\&quot;: \&quot;ORGANIZATION\&quot;}&#x60; (url-encoded of course) would map all records with inbound entity type &#x60;COMPANY&#x60; to &#x60;ORGANIZATION&#x60;.  To map only inbound records with no entity type to a specific entity type you would use an empty JSON property (e.g.: &#x60;{\&quot;\&quot;: \&quot;PERSON\&quot;}&#x60;). If the &#x60;entityType&#x60; parameter is **not** provided and no specific overrides are provided for a record with this parameter or via &#x60;mapEntityType&#x60; then the entity type specified in the inbound record is used directly.  If the record has no entity type and no overriding or mapped entity type is provided for an empty entity type then &#x60;GENERIC&#x60; will be used.  **NOTE**: If both this parameter and the &#x60;mapEntityType&#x60; parameter is provided then the mappings are merged with the more ad-hoc &#x60;mapEntityType&#x60; parameter taking precedence since it is likely being used for debugging and diagnostic purposes to avoid the URL encoding.  Here are some examples of encoding this parameter:  - **JavaScript Example**   &#x60;&#x60;&#x60;javascript     var entityTypeMap &#x3D; {       \&quot;\&quot;: \&quot;PERSON\&quot;,       \&quot;ORG\&quot;: \&quot;ORGANIZATION\&quot;,       \&quot;COMP\&quot;: \&quot;ORGANIZATION\&quot;     };     var mapEntityTypes &#x3D; JSON.stringify(entityTypeMap);     var urlPath &#x3D; \&quot;/bulk-data/load?mapEntityTypes&#x3D;\&quot;                 + encodeURIComponent(mapEntityTypes);   &#x60;&#x60;&#x60;  - **Java Example**   &#x60;&#x60;&#x60;java     JsonObjectBuilder builder &#x3D; Json.createObjectBuilder();     builder.add(\&quot;\&quot;, \&quot;PERSON\&quot;);     builder.add(\&quot;ORG\&quot;, \&quot;ORGANIZATION\&quot;);     builder.add(\&quot;COMP\&quot;, \&quot;ORGANIZATION\&quot;);     JsonObject entityTypeMap &#x3D; builder.build();      String mapEntityTypes &#x3D; entityTypeMap.toString();     String encodedMap     &#x3D; URLEncoder.encode(mapEntityTypes, \&quot;UTF-8\&quot;);     String urlPath &#x3D; \&quot;/bulk-data/load?mapEntityTypes&#x3D;\&quot; + encodedMap;   &#x60;&#x60;&#x60;  In both of the above examples the &#x60;urlPath&#x60; variable is set to: &#x60;&#x60;&#x60;json  /bulk-data/load?mapEntityTypes&#x3D;%7B%22%22%3A%22PERSON%22%2C%22ORG%22%3A%22ORGANIZATION%22%2C%22COMP%22%3A%22ORGANIZATION%22%7D  &#x60;&#x60;&#x60; 
     * @param mapEntityType As an alternative to the &#x60;mapEntityTypes&#x60; parameter you may specify the &#x60;mapEntityType&#x60; parameter zero or more times to add additional data source mappings or **override** data source mappings from &#x60;mapDataSources&#x60;.  If you are using this API programmatically then you should typically use the &#x60;mapDataSources&#x60; parameter instead of this one.  But when manually constructing a URL in the browser address bar, in a command-line tool like &#x60;curl&#x60; or in a REST client browser extension for debugging or testing purposes, encoding the JSON value for &#x60;mapDataSources&#x60; can be unwieldy.  This parameter (which is multi-valued) lets you specify delimited strings that begin with the delimiter character, followed by the original data source name, then the delimiter character and the new data source name.  You should only have to URL-encode the delimiter you choose and maybe spaces.  For example, &#x60;:EMPL:EMPLOYEES&#x60; or &#x60;|EMPL|EMPLOYEES&#x60; (url-encoded of course) would map all records with inbound data source &#x60;EMPL&#x60; to &#x60;EMPLOYEES&#x60;.  To map only inbound records with no data source to a specific data source you would begin the value with two repeated delimiter characters followed by the new data source value (e.g.: &#x60;||CUSTOMERS&#x60; or &#x60;::CUSTOMERS&#x60;). If the &#x60;dataSource&#x60; parameter is **not** provided and no specific overrides are provided for a record with this parameter or the &#x60;mapDataSources&#x60; parameter then the data source specified in the inbound record is used directly.  If the record has no entity type and no overriding or mapped entity type is provided for an empty entity type then &#x60;GENERIC&#x60; will be used. 
     * @param maxBatchCount The maximum number of records to include in a single-message \&quot;micro batch\&quot; when adding to the queue.  If the value is zero or negative then as many records as possible are included in the \&quot;micro batch\&quot; without exceeding the maximum message size.  If one (1) then an array containing a single record is sent.  If greater than one (1) then arrays of multiple items may be sent, providing the total message size is not too large. 
     * @param maxFailures The maximum number of failures that can occur before the bulk load operation is aborted.  If the value is less-than or equal-to zero (0) then the operation will continue regardless of the number of errors that occur. 
     * @param progressPeriod The suggested maximum time between SSE &#x60;progress&#x60; events specified in milliseconds.  If not specified then the default of &#x60;3000&#x60; milliseconds (i.e.: 3 seconds) is used.  This parameter is NOT used if the operation is not producing an SSE response (i.e.: &#x60;text/event-stream&#x60; media type was not requested via the &#x60;Accept&#x60; header).
     * @param eofSendTimeout The number of seconds to wait for an additional Web Sockets message before assuming end-of-file (EOF) when using this end-point via Web Sockets protocol.  If this number of seconds elapses with no additional incoming data then the server assumes that there are no more file chunks forthcoming.  If not specified then the default of &#x60;3&#x60; seconds is used. This parameter is NOT used if the operation is not invoked via the Web Sockets (&#x60;ws://&#x60;) protocol.  **NOTE**: This is specified in seconds, **not** milliseconds.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public streamLoadBulkRecords(body: string, dataSource?: string, mapDataSources?: string, mapDataSource?: Array<string>, entityType?: string, mapEntityTypes?: string, mapEntityType?: Array<string>, maxBatchCount?: number, maxFailures?: number, progressPeriod?: number, eofSendTimeout?: number, observe?: 'body', reportProgress?: boolean): Observable<SzBulkLoadResponse>;
    public streamLoadBulkRecords(body: string, dataSource?: string, mapDataSources?: string, mapDataSource?: Array<string>, entityType?: string, mapEntityTypes?: string, mapEntityType?: Array<string>, maxBatchCount?: number, maxFailures?: number, progressPeriod?: number, eofSendTimeout?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzBulkLoadResponse>>;
    public streamLoadBulkRecords(body: string, dataSource?: string, mapDataSources?: string, mapDataSource?: Array<string>, entityType?: string, mapEntityTypes?: string, mapEntityType?: Array<string>, maxBatchCount?: number, maxFailures?: number, progressPeriod?: number, eofSendTimeout?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzBulkLoadResponse>>;
    public streamLoadBulkRecords(body: string, dataSource?: string, mapDataSources?: string, mapDataSource?: Array<string>, entityType?: string, mapEntityTypes?: string, mapEntityType?: Array<string>, maxBatchCount?: number, maxFailures?: number, progressPeriod?: number, eofSendTimeout?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if(!this.wsPath) {
            throw new Error('WebsocketBasePath is not defined. postRecordToLoadQueue is a WebSocket interface.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling streamLoadBulkRecords.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (dataSource !== undefined && dataSource !== null) {
            queryParameters = queryParameters.set('dataSource', <any>dataSource);
        }
        if (mapDataSources !== undefined && mapDataSources !== null) {
            queryParameters = queryParameters.set('mapDataSources', <any>mapDataSources);
        }
        if (mapDataSource) {
            mapDataSource.forEach((element) => {
                queryParameters = queryParameters.append('mapDataSource', <any>element);
            })
        }
        if (entityType !== undefined && entityType !== null) {
            queryParameters = queryParameters.set('entityType', <any>entityType);
        }
        if (mapEntityTypes !== undefined && mapEntityTypes !== null) {
            queryParameters = queryParameters.set('mapEntityTypes', <any>mapEntityTypes);
        }
        if (mapEntityType) {
            mapEntityType.forEach((element) => {
                queryParameters = queryParameters.append('mapEntityType', <any>element);
            })
        }
        if (maxBatchCount !== undefined && maxBatchCount !== null) {
            queryParameters = queryParameters.set('maxBatchCount', <any>maxBatchCount);
        }
        if (maxFailures !== undefined && maxFailures !== null) {
            queryParameters = queryParameters.set('maxFailures', <any>maxFailures);
        }
        if (progressPeriod !== undefined && progressPeriod !== null) {
            queryParameters = queryParameters.set('progressPeriod', <any>progressPeriod);
        }
        if (eofSendTimeout !== undefined && eofSendTimeout !== null) {
            queryParameters = queryParameters.set('eofSendTimeout', <any>eofSendTimeout);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/x-jsonlines; charset=UTF-8',
            'application/x-jsonlines',
            'application/json; charset=UTF-8',
            'application/json',
            'text/csv; charset=UTF-8',
            'text/csv',
            'text/plain; charset=UTF-8',
            'text/plain',
            'multipart/form-data'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<SzBulkLoadResponse>('post',`${this.basePath}/load-queue/bulk-data/records`,
            {
                body: body,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Load the records in the provided bulk data set. (Supports SSE / Supports Web Sockets)
     * Provides a means to load a bulk data file of records via an asynchronous load queue.  The records are encoded as a JSON array of JSON objects, a single JSON object per line in JSON-lines file format, or as a CSV with one record per row.  The data should be in pre-mapped format using JSON property names or CSV column names as described by the [Senzing Generic Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification).  **SCALABILITY NOTE:** This operation can be invoked in three ways.  In order of increasingly better scalability these are listed below:   1. Standard HTTP Request/Response   2. HTTP Request with SSE Response (see below)   3. HTTP Upgrade Request for Web Sockets (see below)  Standard HTTP Request/Response (method 1) has the worst scalability because a long-running operation will tie up a Web Server thread **and** continue until complete even if the client aborts the operation since no data is written back to the client until complete and therefore the terminated connection will not be detected.  SSE (method 2) mitigates the problem of detecting when a client has aborted the operation because periodic progress responses are written to the client and therefore a terminated connection will be detected.  However, the best way to invoke this operation is via Web Sockets (method 3) which not only can detect disconnection of the client, but it also upgrades the request to use its own thread outside the Web Server thread pool.  **SSE NOTE:** This end-point supports \&quot;Server-sent Events\&quot; (SSE) via the &#x60;text/event-stream&#x60; media type.  This support is activated by adding the &#x60;Accept: text/event-stream&#x60; header to a request to override the default &#x60;application/json&#x60; media type.  Further, the end-point will behave similarly to its standard operation but will produce &#x60;progress&#x60; events at regular intervals that are equivalent to its &#x60;200&#x60; response schema. Upon success, the final event will be &#x60;completed&#x60; with the same response schema as a &#x60;200&#x60; response.  Upon failure, the final event will be &#x60;failed&#x60; with same &#x60;SzErrorResponse&#x60; schema as the &#x60;4xx&#x60; or &#x60;5xx&#x60;.  **WEB SOCKETS NOTE**: If invoking via Web Sockets then the client may send text or binary chunks of the JSON, JSON-Lines or CSV bulk data file as messages.  In Web Sockets, text messages are *always* sent as UTF-8. If the file&#x27;s character encoding is unknown then the client should send binary messages and the server will attempt to auto-detect the character encoding.  Each message should adhere to the maximum message size specified by the &#x60;webSocketsMessageMaxSize&#x60; property returned by the &#x60;GET /server-info&#x60; end-point.  The end of file is detected when the number of seconds specified by the &#x60;eofSendTimeout&#x60; query parameter have elapsed without a new message being received. 
     * @param body 
     * @param dataSource Used to set the overriding data source for the records.  This data source will be assigned to every record **unless** the record&#x27;s data source (including blank data source) has a specific mapping specified by a &#x60;mapDataSources&#x60; or &#x60;mapDataSource&#x60; parameters.  If this parameter is **not** provided and no specific overrides are provided for a record then the data source specified in the inbound record is used directly.  If the record has no data source and no override is provided then it will fail to load. 
     * @param mapDataSources A URL-encoded JSON object whose properties are interpreted as data source codes to map from and whose corresponding values are interpretted as data source codes to map to.  For example, &#x60;{\&quot;EMPL\&quot;: \&quot;EMPLOYEES\&quot;}&#x60; (url-encoded of course) would map all records with inbound data source &#x60;EMPL&#x60; to &#x60;EMPLOYEES&#x60;.  To map only inbound records with no data source to a specific data source you would use an empty JSON property (e.g.: &#x60;{\&quot;\&quot;: \&quot;CUSTOMERS\&quot;}&#x60;). If the &#x60;dataSource&#x60; parameter is **not** provided and no specific overrides are provided for a record with this parameter or via &#x60;mapDataSource&#x60; then the data source specified in the inbound record is used directly.  If the record has no data source and no overriding or mapped data source is provided for an empty data source then the record will fail to load.  **NOTE**: If both this parameter and the &#x60;mapDataSource&#x60; parameter is provided then the mappings are merged with the more ad-hoc &#x60;mapDataSource&#x60; parameter taking precedence since it is likely being used for debugging and diagnostic purposes to avoid the URL encoding.  Here are some examples of encoding this parameter:  - **JavaScript Example**   &#x60;&#x60;&#x60;javascript     var dataSourceMap &#x3D; {       \&quot;\&quot;: \&quot;CUSTOMERS\&quot;,       \&quot;EMPL\&quot;: \&quot;EMPLOYEES\&quot;,       \&quot;VEND\&quot;: \&quot;VENDORS\&quot;     };     var mapDataSources &#x3D; JSON.stringify(dataSourceMap);     var urlPath &#x3D; \&quot;/bulk-data/load?mapDataSources&#x3D;\&quot;                 + encodeURIComponent(mapDataSources);   &#x60;&#x60;&#x60;  - **Java Example**   &#x60;&#x60;&#x60;java     JsonObjectBuilder builder &#x3D; Json.createObjectBuilder();     builder.add(\&quot;\&quot;, \&quot;CUSTOMERS\&quot;);     builder.add(\&quot;EMPL\&quot;, \&quot;EMPLOYEES\&quot;);     builder.add(\&quot;VEND\&quot;, \&quot;VENDORS\&quot;);     JsonObject dataSourceMap &#x3D; builder.build();      String mapDataSources &#x3D; dataSourceMap.toString();     String encodedMap     &#x3D; URLEncoder.encode(mapDataSources, \&quot;UTF-8\&quot;);     String urlPath &#x3D; \&quot;/bulk-data/load?mapDataSources&#x3D;\&quot; + encodedMap;   &#x60;&#x60;&#x60;  In both of the above examples the &#x60;urlPath&#x60; variable is set to: &#x60;&#x60;&#x60;json  /bulk-data/load?mapDataSources&#x3D;%7B%22%22%3A%22CUSTOMERS%22%2C%22EMPL%22%3A%22EMPLOYEES%22%2C%22VEND%22%3A%22VENDORS%22%7D  &#x60;&#x60;&#x60; 
     * @param mapDataSource As an alternative to the &#x60;mapDataSources&#x60; parameter you may specify the &#x60;mapDataSource&#x60; parameter zero or more times to add additional data source mappings or **override** data source mappings from &#x60;mapDataSources&#x60;.  If you are using this API programmatically then you should typically use the &#x60;mapDataSources&#x60; parameter instead of this one.  But when manually constructing a URL in the browser address bar, in a command-line tool like &#x60;curl&#x60; or in a REST client browser extension for debugging or testing purposes, encoding the JSON value for &#x60;mapDataSources&#x60; can be unwieldy.  This parameter (which is multi-valued) lets you specify delimited strings that begin with the delimiter character, followed by the original data source name, then the delimiter character and the new data source name.  You should only have to URL-encode the delimiter you choose and maybe spaces.  For example, &#x60;:EMPL:EMPLOYEES&#x60; or &#x60;|EMPL|EMPLOYEES&#x60; (url-encoded of course) would map all records with inbound data source &#x60;EMPL&#x60; to &#x60;EMPLOYEES&#x60;.  To map only inbound records with no data source to a specific data source you would begin the value with two repeated delimiter characters followed by the new data source value (e.g.: &#x60;||CUSTOMERS&#x60; or &#x60;::CUSTOMERS&#x60;). If the &#x60;dataSource&#x60; parameter is **not** provided and no specific overrides are provided for a record with this parameter or the &#x60;mapDataSources&#x60; parameter then the data source specified in the inbound record is used directly.  If the record has no data source and no overriding or mapped data source is provided for an empty data source then the record will fail to load. 
     * @param entityType Used to set the overriding entity type for the records.  This entity type will be assigned to every record **unless** the record&#x27;s entity type (including blank entity type) has a specific mapping specified by a &#x60;mapEntityTypes&#x60; or &#x60;mapEntityType&#x60; parameters.  If this parameter is **not** provided and no specific overrides are provided for a record then the entity type specified in the inbound record is used directly.  If the record has no entity type and no override is provided then &#x60;GENERIC&#x60; will be used.
     * @param mapEntityTypes A URL-encoded JSON object whose properties are interpreted as entity type codes to map from and whose corresponding values are interpretted as entity type codes to map to.  For example, &#x60;{\&quot;COMPANY\&quot;: \&quot;ORGANIZATION\&quot;}&#x60; (url-encoded of course) would map all records with inbound entity type &#x60;COMPANY&#x60; to &#x60;ORGANIZATION&#x60;.  To map only inbound records with no entity type to a specific entity type you would use an empty JSON property (e.g.: &#x60;{\&quot;\&quot;: \&quot;PERSON\&quot;}&#x60;). If the &#x60;entityType&#x60; parameter is **not** provided and no specific overrides are provided for a record with this parameter or via &#x60;mapEntityType&#x60; then the entity type specified in the inbound record is used directly.  If the record has no entity type and no overriding or mapped entity type is provided for an empty entity type then &#x60;GENERIC&#x60; will be used.  **NOTE**: If both this parameter and the &#x60;mapEntityType&#x60; parameter is provided then the mappings are merged with the more ad-hoc &#x60;mapEntityType&#x60; parameter taking precedence since it is likely being used for debugging and diagnostic purposes to avoid the URL encoding.  Here are some examples of encoding this parameter:  - **JavaScript Example**   &#x60;&#x60;&#x60;javascript     var entityTypeMap &#x3D; {       \&quot;\&quot;: \&quot;PERSON\&quot;,       \&quot;ORG\&quot;: \&quot;ORGANIZATION\&quot;,       \&quot;COMP\&quot;: \&quot;ORGANIZATION\&quot;     };     var mapEntityTypes &#x3D; JSON.stringify(entityTypeMap);     var urlPath &#x3D; \&quot;/bulk-data/load?mapEntityTypes&#x3D;\&quot;                 + encodeURIComponent(mapEntityTypes);   &#x60;&#x60;&#x60;  - **Java Example**   &#x60;&#x60;&#x60;java     JsonObjectBuilder builder &#x3D; Json.createObjectBuilder();     builder.add(\&quot;\&quot;, \&quot;PERSON\&quot;);     builder.add(\&quot;ORG\&quot;, \&quot;ORGANIZATION\&quot;);     builder.add(\&quot;COMP\&quot;, \&quot;ORGANIZATION\&quot;);     JsonObject entityTypeMap &#x3D; builder.build();      String mapEntityTypes &#x3D; entityTypeMap.toString();     String encodedMap     &#x3D; URLEncoder.encode(mapEntityTypes, \&quot;UTF-8\&quot;);     String urlPath &#x3D; \&quot;/bulk-data/load?mapEntityTypes&#x3D;\&quot; + encodedMap;   &#x60;&#x60;&#x60;  In both of the above examples the &#x60;urlPath&#x60; variable is set to: &#x60;&#x60;&#x60;json  /bulk-data/load?mapEntityTypes&#x3D;%7B%22%22%3A%22PERSON%22%2C%22ORG%22%3A%22ORGANIZATION%22%2C%22COMP%22%3A%22ORGANIZATION%22%7D  &#x60;&#x60;&#x60; 
     * @param mapEntityType As an alternative to the &#x60;mapEntityTypes&#x60; parameter you may specify the &#x60;mapEntityType&#x60; parameter zero or more times to add additional data source mappings or **override** data source mappings from &#x60;mapDataSources&#x60;.  If you are using this API programmatically then you should typically use the &#x60;mapDataSources&#x60; parameter instead of this one.  But when manually constructing a URL in the browser address bar, in a command-line tool like &#x60;curl&#x60; or in a REST client browser extension for debugging or testing purposes, encoding the JSON value for &#x60;mapDataSources&#x60; can be unwieldy.  This parameter (which is multi-valued) lets you specify delimited strings that begin with the delimiter character, followed by the original data source name, then the delimiter character and the new data source name.  You should only have to URL-encode the delimiter you choose and maybe spaces.  For example, &#x60;:EMPL:EMPLOYEES&#x60; or &#x60;|EMPL|EMPLOYEES&#x60; (url-encoded of course) would map all records with inbound data source &#x60;EMPL&#x60; to &#x60;EMPLOYEES&#x60;.  To map only inbound records with no data source to a specific data source you would begin the value with two repeated delimiter characters followed by the new data source value (e.g.: &#x60;||CUSTOMERS&#x60; or &#x60;::CUSTOMERS&#x60;). If the &#x60;dataSource&#x60; parameter is **not** provided and no specific overrides are provided for a record with this parameter or the &#x60;mapDataSources&#x60; parameter then the data source specified in the inbound record is used directly.  If the record has no entity type and no overriding or mapped entity type is provided for an empty entity type then &#x60;GENERIC&#x60; will be used. 
     * @param maxBatchCount The maximum number of records to include in a single-message \&quot;micro batch\&quot; when adding to the queue.  If the value is zero or negative then as many records as possible are included in the \&quot;micro batch\&quot; without exceeding the maximum message size.  If one (1) then an array containing a single record is sent.  If greater than one (1) then arrays of multiple items may be sent, providing the total message size is not too large. 
     * @param maxFailures The maximum number of failures that can occur before the bulk load operation is aborted.  If the value is less-than or equal-to zero (0) then the operation will continue regardless of the number of errors that occur. 
     * @param progressPeriod The suggested maximum time between SSE &#x60;progress&#x60; events specified in milliseconds.  If not specified then the default of &#x60;3000&#x60; milliseconds (i.e.: 3 seconds) is used.  This parameter is NOT used if the operation is not producing an SSE response (i.e.: &#x60;text/event-stream&#x60; media type was not requested via the &#x60;Accept&#x60; header).
     * @param eofSendTimeout The number of seconds to wait for an additional Web Sockets message before assuming end-of-file (EOF) when using this end-point via Web Sockets protocol.  If this number of seconds elapses with no additional incoming data then the server assumes that there are no more file chunks forthcoming.  If not specified then the default of &#x60;3&#x60; seconds is used. This parameter is NOT used if the operation is not invoked via the Web Sockets (&#x60;ws://&#x60;) protocol.  **NOTE**: This is specified in seconds, **not** milliseconds.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public streamLoadBulkRecordsForm(body: Blob, dataSource?: string, mapDataSources?: string, mapDataSource?: Array<string>, entityType?: string, mapEntityTypes?: string, mapEntityType?: Array<string>, maxBatchCount?: number, maxFailures?: number, progressPeriod?: number, eofSendTimeout?: number, observe?: 'body', reportProgress?: boolean): Observable<SzBulkLoadResponse>;
    public streamLoadBulkRecordsForm(body: Blob, dataSource?: string, mapDataSources?: string, mapDataSource?: Array<string>, entityType?: string, mapEntityTypes?: string, mapEntityType?: Array<string>, maxBatchCount?: number, maxFailures?: number, progressPeriod?: number, eofSendTimeout?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SzBulkLoadResponse>>;
    public streamLoadBulkRecordsForm(body: Blob, dataSource?: string, mapDataSources?: string, mapDataSource?: Array<string>, entityType?: string, mapEntityTypes?: string, mapEntityType?: Array<string>, maxBatchCount?: number, maxFailures?: number, progressPeriod?: number, eofSendTimeout?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SzBulkLoadResponse>>;
    public streamLoadBulkRecordsForm(body: Blob, dataSource?: string, mapDataSources?: string, mapDataSource?: Array<string>, entityType?: string, mapEntityTypes?: string, mapEntityType?: Array<string>, maxBatchCount?: number, maxFailures?: number, progressPeriod?: number, eofSendTimeout?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if(!this.wsPath) {
            throw new Error('WebsocketBasePath is not defined. postRecordToLoadQueue is a WebSocket interface.');
        }
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling streamLoadBulkRecords.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (dataSource !== undefined && dataSource !== null) {
            queryParameters = queryParameters.set('dataSource', <any>dataSource);
        }
        if (mapDataSources !== undefined && mapDataSources !== null) {
            queryParameters = queryParameters.set('mapDataSources', <any>mapDataSources);
        }
        if (mapDataSource) {
            mapDataSource.forEach((element) => {
                queryParameters = queryParameters.append('mapDataSource', <any>element);
            })
        }
        if (entityType !== undefined && entityType !== null) {
            queryParameters = queryParameters.set('entityType', <any>entityType);
        }
        if (mapEntityTypes !== undefined && mapEntityTypes !== null) {
            queryParameters = queryParameters.set('mapEntityTypes', <any>mapEntityTypes);
        }
        if (mapEntityType) {
            mapEntityType.forEach((element) => {
                queryParameters = queryParameters.append('mapEntityType', <any>element);
            })
        }
        if (maxBatchCount !== undefined && maxBatchCount !== null) {
            queryParameters = queryParameters.set('maxBatchCount', <any>maxBatchCount);
        }
        if (maxFailures !== undefined && maxFailures !== null) {
            queryParameters = queryParameters.set('maxFailures', <any>maxFailures);
        }
        if (progressPeriod !== undefined && progressPeriod !== null) {
            queryParameters = queryParameters.set('progressPeriod', <any>progressPeriod);
        }
        if (eofSendTimeout !== undefined && eofSendTimeout !== null) {
            queryParameters = queryParameters.set('eofSendTimeout', <any>eofSendTimeout);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json; charset=UTF-8',
            'application/json',
            'default'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/x-jsonlines; charset=UTF-8',
            'application/x-jsonlines',
            'application/json; charset=UTF-8',
            'application/json',
            'text/csv; charset=UTF-8',
            'text/csv',
            'text/plain; charset=UTF-8',
            'text/plain',
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (body !== undefined) {
            formParams = formParams.append('body', <any>body) as any || formParams;
        }

        return this.httpClient.request<SzBulkLoadResponse>('post',`${this.basePath}/load-queue/bulk-data/records`,
            {
                body: convertFormParamsToString ? formParams.toString() : formParams,
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
